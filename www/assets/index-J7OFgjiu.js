const O = window.Plotly; (function () { const t = document.createElement("link").relList; if (t && t.supports && t.supports("modulepreload")) return; for (const o of document.querySelectorAll('link[rel="modulepreload"]')) s(o); new MutationObserver(o => { for (const n of o) if (n.type === "childList") for (const r of n.addedNodes) r.tagName === "LINK" && r.rel === "modulepreload" && s(r) }).observe(document, { childList: !0, subtree: !0 }); function a(o) { const n = {}; return o.integrity && (n.integrity = o.integrity), o.referrerPolicy && (n.referrerPolicy = o.referrerPolicy), o.crossOrigin === "use-credentials" ? n.credentials = "include" : o.crossOrigin === "anonymous" ? n.credentials = "omit" : n.credentials = "same-origin", n } function s(o) { if (o.ep) return; o.ep = !0; const n = a(o); fetch(o.href, n) } })(); const F = { lfsr: (e, t, a) => { let s = 1; const o = [], n = (1 << e) - 1; for (let r = 0; r < a; r++) { let i = 0; t.forEach(p => { i ^= s >> p - 1 & 1 }), o.push(s & 1), s = (s << 1 | i) & n, s === 0 && (s = 1) } return o }, getRRC: (e, t, a) => { const s = e * t, o = new Float32Array(s + 1), n = a; for (let r = 0; r <= s; r++) { const i = (r - s / 2) / t; if (Math.abs(i) < 1e-10) o[r] = 1 - n + 4 * n / Math.PI; else if (n !== 0 && Math.abs(Math.abs(i) - 1 / (4 * n)) < 1e-10) o[r] = n / Math.sqrt(2) * ((1 + 2 / Math.PI) * Math.sin(Math.PI / (4 * n)) + (1 - 2 / Math.PI) * Math.cos(Math.PI / (4 * n))); else { const p = Math.sin(Math.PI * i * (1 - n)) + 4 * n * i * Math.cos(Math.PI * i * (1 + n)), f = Math.PI * i * (1 - Math.pow(4 * n * i, 2)); o[r] = p / f } } return o }, convolve: (e, t) => { const a = new Float32Array(e.length), s = Math.floor(t.length / 2); for (let o = 0; o < e.length; o++) { let n = 0; for (let r = 0; r < t.length; r++) { const i = o - r + s; i >= 0 && i < e.length && (n += e[i] * t[r]) } a[o] = n } return a }, simulateLinearGeneric: (e, t, a, s, o, n, r, i, p) => { const f = Math.max(1, Math.log2(t)), g = [], c = Math.sqrt(t); for (let m = 0; m < n; m++) { const b = e.slice(m * f, (m + 1) * f), y = b.reduce((h, I, k) => h + (I << f - 1 - k), 0), S = y ^ y >> 1; if (p === "qam" && Number.isInteger(c)) { const h = f / 2, I = b.slice(0, h).reduce((P, E, T) => P + (E << h - 1 - T), 0), k = b.slice(h).reduce((P, E, T) => P + (E << h - 1 - T), 0), w = I ^ I >> 1, Q = k ^ k >> 1; g.push({ I: 2 * w - (c - 1), Q: 2 * Q - (c - 1), val: w + Q * c }) } else if (p === "psk") { const h = 2 * Math.PI * S / t + Math.PI / t; g.push({ I: Math.cos(h), Q: Math.sin(h), val: S }) } else p === "fsk" ? g.push({ f_idx: y, val: y }) : g.push({ I: 2 * S - (t - 1), Q: 0, val: S }) } const _ = Math.max(1, a / f), v = _ * o, l = n * o; let u, d; if (p === "fsk") { u = new Float32Array(l), d = new Float32Array(l); const m = new Float32Array(l); for (let S = 0; S < n; S++) { const h = (g[S].f_idx - (t - 1) / 2) * _; for (let I = 0; I < o; I++) { const k = S * o + I; u[k] = Math.cos(2 * Math.PI * h * I / v), d[k] = Math.sin(2 * Math.PI * h * I / v), m[k] = s + h } } const b = new Float32Array(l).map((S, h) => h / v), y = new Float32Array(l).map((S, h) => u[h] * Math.cos(2 * Math.PI * s * b[h]) - d[h] * Math.sin(2 * Math.PI * s * b[h])); return { t: b, bbI: u, bbQ: d, pb: y, fInst: m, bits: e, symbols: g, isVector: !1 } } else { const m = F.getRRC(i, o, r), b = p === "ask" || p === "qam" || p === "psk" ? 1 / Math.sqrt(g.reduce((k, w) => k + w.I * w.I + w.Q * w.Q, 0) / n) : 1, y = new Float32Array(l), S = new Float32Array(l); for (let k = 0; k < n; k++)y[k * o] = g[k].I * b, S[k * o] = g[k].Q * b; u = F.convolve(y, m), d = F.convolve(S, m); const h = new Float32Array(l).map((k, w) => w / v), I = new Float32Array(l).map((k, w) => u[w] * Math.cos(2 * Math.PI * s * h[w]) - d[w] * Math.sin(2 * Math.PI * s * h[w])); return { t: h, bbI: u, bbQ: d, pb: I, fInst: new Float32Array(l).fill(s), bits: e, symbols: g, isVector: !0 } } } },
    X = { id: "qam", name: "M-QAM (Quadrature)", params: ["M", "FC", "RB", "ALPHA"], requiredBits: e => e.Nc * Math.max(1, Math.log2(e.M)), help: "modm_qam_desc", info2: "chart_2_sym_mapping", info3: "chart_3_baseband", info4: "chart_4_tech_vector", showConstellation: !0, simulate: (e, t) => { const a = F.simulateLinearGeneric(t, e.M, e.Rb, e.fc, e.sps, e.Nc, e.rolloff, e.span, "qam"); return { ...a, extras: { envelope: a.bbI.map((s, o) => Math.sqrt(s * s + a.bbQ[o] * a.bbQ[o])) } } } }, ee = { id: "psk", name: "M-PSK (Phase Shift)", params: ["M", "FC", "RB", "ALPHA"], requiredBits: e => e.Nc * Math.max(1, Math.log2(e.M)), help: "modm_psk_desc", info2: "chart_2_sym_mapping", info3: "chart_3_baseband", info4: "chart_4_tech_vector", showConstellation: !0, simulate: (e, t) => F.simulateLinearGeneric(t, e.M, e.Rb, e.fc, e.sps, e.Nc, e.rolloff, e.span, "psk") }, te = { id: "ask", name: "M-ASK (Amplitude)", params: ["M", "FC", "RB", "ALPHA"], requiredBits: e => e.Nc * Math.max(1, Math.log2(e.M)), help: "modm_ask_desc", info2: "chart_2_sym_mapping", info3: "chart_3_baseband", info4: "chart_4_tech_vector", showConstellation: !0, simulate: (e, t) => { const a = F.simulateLinearGeneric(t, e.M, e.Rb, e.fc, e.sps, e.Nc, e.rolloff, e.span, "ask"); return { ...a, extras: { envelope: a.bbI.map((s, o) => Math.sqrt(s * s + a.bbQ[o] * a.bbQ[o])) } } } }, oe = { id: "fsk", name: "M-FSK (Frequency)", params: ["M", "FC", "RB"], requiredBits: e => e.Nc * Math.max(1, Math.log2(e.M)), help: "modm_fsk_desc", info2: "chart_2_sym_mapping", info3: "chart_3_baseband", info4: "chart_4_tech_freq", showConstellation: !1, simulate: (e, t) => F.simulateLinearGeneric(t, e.M, e.Rb, e.fc, e.sps, e.Nc, e.rolloff, e.span, "fsk") }, ae = { id: "css", name: "CSS (LoRa Chirp)", params: ["FC", "RB", "SF", "BW"], requiredBits: e => 4 * e.SF, help: "modm_css_desc", info2: "chart_2_sym_mapping", info3: "chart_3_baseband", info4: "chart_4_tech_freq", showConstellation: !1, simulate: (e, t) => { const a = e.SF, s = Math.pow(2, a), o = e.BW, n = s / o, r = Math.floor(t.length / a), i = []; for (let l = 0; l < r; l++) { const u = t.slice(l * a, (l + 1) * a); i.push({ shift: u.reduce((d, m, b) => d + (m << a - 1 - b), 0), val: u.reduce((d, m, b) => d + (m << a - 1 - b), 0) }) } const p = r * s, f = new Float32Array(p), g = new Float32Array(p), c = new Float32Array(p), _ = new Float32Array(p), v = new Float32Array(p); for (let l = 0; l < r; l++) { const u = i[l].shift; for (let d = 0; d < s; d++) { const m = l * s + d, b = d / o; f[m] = m / o; const y = -o / 2 + o / n * ((b + u * n / s) % n); g[m] = Math.cos(2 * Math.PI * y * b), c[m] = Math.sin(2 * Math.PI * y * b), v[m] = e.fc + y, _[m] = g[m] * Math.cos(2 * Math.PI * e.fc * f[m]) - c[m] * Math.sin(2 * Math.PI * e.fc * f[m]) } } return { t: f, bbI: g, bbQ: c, pb: _, fInst: v, bits: t, symbols: i, extras: { m_indices: i.map(l => l.shift) }, plot2Type: "markers" } } }, ne = { id: "dsss", name: "DSSS (Direct Sequence)", params: ["FC", "RB", "L"], requiredBits: e => 10, help: "modm_dsss_desc", info2: "chart_2_spread_code", info3: "chart_3_spread_sig", info4: "chart_4_tech_freq", showConstellation: !1, simulate: (e, t) => { const a = t.length, s = F.lfsr(7, [7, 3], a * e.L).map(l => 2 * l - 1), o = []; t.forEach(l => { const u = 2 * l - 1; for (let d = 0; d < e.L; d++)o.push(u) }); const n = o.map((l, u) => l * s[u]), r = 8, i = n.length * r, p = e.Rb * e.L * r, f = new Float32Array(i), g = new Float32Array(i), c = new Float32Array(i), _ = new Float32Array(i), v = new Float32Array(i).fill(e.fc); for (let l = 0; l < n.length; l++)for (let u = 0; u < r; u++) { const d = l * r + u; f[d] = d / p, g[d] = n[l], _[d] = g[d] * Math.cos(2 * Math.PI * e.fc * f[d]) } return { t: f, bbI: g, bbQ: c, pb: _, fInst: v, bits: t, symbols: t.map(l => ({ val: l })), extras: { plot2_x: Array.from({ length: s.slice(0, 128).length }, (l, u) => u), plot2_y: s.slice(0, 128) }, plot2Type: "markers+lines" } } }, se = { id: "fhss", name: "FHSS (Freq. Hopping)", params: ["M", "FC", "RB", "BW", "RH"], requiredBits: e => 100, help: "modm_fhss_desc", info2: "chart_2_hop_code", info3: "chart_3_baseband", info4: "chart_4_tech_freq", showConstellation: !1, simulate: (e, t) => { const a = t.length, s = e.M, o = e.BW / e.M, n = 16, r = e.Rb * n, i = Math.max(1, Math.floor(e.Rb / e.Rh)), p = F.lfsr(8, [8, 4, 3, 2], Math.ceil(a / i)), f = a * n, g = new Float32Array(f), c = new Float32Array(f), _ = new Float32Array(f), v = new Float32Array(f), l = new Float32Array(f); for (let u = 0; u < a; u++) { const d = Math.floor(u / i), b = (p[d] % s - (s - 1) / 2) * o, y = 2 * t[u] - 1; for (let S = 0; S < n; S++) { const h = u * n + S; g[h] = h / r, c[h] = y * Math.cos(2 * Math.PI * b * h / r), _[h] = y * Math.sin(2 * Math.PI * b * h / r), l[h] = e.fc + b, v[h] = c[h] * Math.cos(2 * Math.PI * e.fc * g[h]) - _[h] * Math.sin(2 * Math.PI * e.fc * g[h]) } } return { t: g, bbI: c, bbQ: _, pb: v, fInst: l, bits: t, symbols: t.map(u => ({ val: u })), extras: { plot2_x: Array.from({ length: p.slice(0, 60).length }, (u, d) => d), plot2_y: p.slice(0, 60) }, plot2Type: "markers+lines" } } }, re = { id: "thss", name: "THSS (Time Hopping)", params: ["FC", "RB", "SLOTS"], requiredBits: e => 40, help: "modm_thss_desc", info2: "chart_2_hop_code", info3: "chart_3_baseband", info4: "chart_4_tech_freq", showConstellation: !1, simulate: (e, t) => { const a = t.length, s = F.lfsr(7, [7, 3], a), o = 200, r = o / .001, i = a * o, p = new Float32Array(i), f = new Float32Array(i), g = new Float32Array(i), c = new Float32Array(i), _ = new Float32Array(i).fill(e.fc); for (let l = 0; l < a; l++) { const u = s[l] % e.SLOTS, d = 2 * t[l] - 1, m = l * o + Math.floor(u * (o / e.SLOTS)); for (let y = 0; y < o; y++)p[l * o + y] = (l * o + y) / r; const b = 5; for (let y = 0; y < b; y++)m + y < i && (f[m + y] = d * Math.exp(-y), c[m + y] = f[m + y] * Math.cos(2 * Math.PI * e.fc * p[m + y])) } const v = s.slice(0, 40).map(l => l % e.SLOTS); return { t: p, bbI: f, bbQ: g, pb: c, fInst: _, bits: t, symbols: t.map(l => ({ val: l })), extras: { plot2_x: Array.from({ length: v.length }, (l, u) => u), plot2_y: v }, plot2Type: "markers" } } }, K = { M: { id: "m-order", numId: "m-in", label: "Order [M]", containerClass: "param-std", min: 1, max: 10, step: 1, default: 6, isLogM: !0 }, FC: { id: "fc", numId: "fc-in", label: "Carrier [fc] kHz", min: 1, max: 5e3, step: 1, default: 50 }, RB: { id: "rb", numId: "rb-in", label: "Bit Rate [Rb] kbps", min: .1, max: 1e3, step: .1, default: 10 }, ALPHA: { id: "rolloff", numId: "rolloff-in", label: "Pulse α", containerClass: "param-alpha", min: 0, max: 1, step: .01, default: .35 }, SF: { id: "sf", numId: "sf-in", label: "LoRa SF", containerClass: "param-sf", min: 5, max: 16, step: 1, default: 8 }, BW: { id: "bw", numId: "bw-in", label: "Bandwidth [BW] kHz", containerClass: "param-bw", min: 1, max: 1e3, step: 1, default: 125 }, L: { id: "l-chips", numId: "l-in", label: "Chips [L]", containerClass: "param-l", min: 1, max: 1023, step: 1, default: 31 }, SLOTS: { id: "th-slots", numId: "slots-in", label: "TH Slots", containerClass: "param-slots", min: 1, max: 128, step: 1, default: 8 }, RH: { id: "rh", numId: "rh-in", label: "Hop [Rh] s⁻¹", containerClass: "param-rh", min: 1, max: 1e4, step: 10, default: 1e3 } }, W = [X, ee, te, oe, ae, ne, se, re]; class le { constructor() { this.M = 64, this.Rb = 1e4, this.rolloff = .35, this.fc = 5e4, this.sps = 32, this.span = 8, this.Nc = 30, this.L = 31, this.SF = 8, this.BW = 125e3, this.Rh = 1e3, this.N_th = 8, this.cachedBits = null, this.cachedModType = null, this.cachedNc = null, this.cachedM = null, this.registry = {}, W.forEach(t => { this.registry[t.id] = t }) } getAvailableModulations() { return W.map(t => ({ id: t.id, name: t.name })) } getModulationDef(t) { return this.registry[t] } generateBits(t) { return Array.from({ length: t }, () => Math.random() > .5 ? 1 : 0) } simulate(t, a = !1) { const s = this.registry[t]; if (!s) return console.error(`Modulation type ${t} not registered!`), null; if (a || !this.cachedBits || this.cachedModType !== t || this.cachedNc !== this.Nc || this.cachedM !== this.M) { const i = s.requiredBits(this); this.cachedBits = this.generateBits(i), this.cachedModType = t, this.cachedNc = this.Nc, this.cachedM = this.M } const n = this.cachedBits; return s.simulate(this, n) } } const G = { mod: "mod-type", mRange: "m-order", mNum: "m-in", fcRange: "fc", fcNum: "fc-in", rbRange: "rb", rbNum: "rb-in", rollRange: "rolloff", rollNum: "rolloff-in", sfRange: "sf", sfNum: "sf-in", bwRange: "bw", bwNum: "bw-in", lRange: "l-chips", lNum: "l-in", slotsRange: "th-slots", slotsNum: "slots-in", rhRange: "rh", rhNum: "rh-in", spsRange: "sps", spsNum: "sps-in", ncRange: "nc", ncNum: "nc-in", randomCheck: "random-data", regenBtn: "regen-data", themeBtn: "theme-toggle", presBtn: "pres-toggle", menuBtn: "menu-toggle", helpBtn: "show-help-btn", langToggle: "lang-toggle" }, M = {}; Object.keys(G).forEach(e => M[e] = document.getElementById(G[e])); const V = document.getElementById("help-panel"), ie = [1, 2, 3, 4, 5].map(e => document.getElementById(`info-${e}`)); document.getElementById("app"); const $ = document.getElementById("welcome-modal"), ce = document.getElementById("close-modal-btn"), de = document.getElementById("focus-overlay"), U = document.getElementById("focus-close"), ue = document.getElementById("focus-plot-container"), me = { menu_params: "Parametry", menu_presentation: "Prezentace & Výuka", lbl_modulation: "Modulační cesta", lbl_random_data: "Náhodná data", btn_regen: "Regen", lbl_order: "Řád [M]", lbl_carrier: "Nosná [fc] kHz", lbl_bitrate: "Bitová rychlost [Rb] kbps", lbl_pulse: "Alfa pulzu α", lbl_sf: "LoRa SF", lbl_bw: "Šířka pásma [BW]", lbl_chips: "Čipy [L]", lbl_slots: "TH Sloty", lbl_hop: "Hop [Rh]", lbl_samples: "Vzorků/Sym", lbl_symbol_count: "Počet symbolů", btn_guide: "PRŮVODCE APLIKACÍ", btn_presentation: "PRESENTATION MODE", header_title: "Modulation Lab", header_status: "Status systému: Pico W - SIGNAL LOCK v4.0", divider_legend: "LEGENDA / NÁPOVĚDA", divider_engine: "NASTAVENÍ ENGINU", help_initial: "Vyberte modulaci pro zobrazení detailů.", info_source: "Zdroj: Rb = {rb} kbps | Bit t = {t} ms", info_baseband: "Baseband: SPS = {sps} | f_sampling = {fs} kHz", tt_random_data: "Zaškrtnutím bude aplikace při každém překreslení generovat nová náhodná datová slova. Tlačítkem Regen můžete ručně vygenerovat novou zprávu a vynutit překreslení nezávisle na změnách v parametrech.", tt_order: "Řád modulace. Udává celkový počet distinktních (jedinečných) stavů symbolů v konstelaci. Čím vyšší řád, tím více bitů přeneseme jedním symbolem, roste ale riziko chyb (BER).", tt_carrier: "Nosná frekvence. Základní (oscilační) kmitočet sinusovky, tzv. nosné vlny. Právě do změn její fáze, amplitudy či frekvence je podle zvolené modulace ukryta samotná zpráva.", tt_bitrate: "Přenosová (bitová) rychlost. Kolik jedniček a nul chrlí datový generátor za sekundu (zde v tisících - kbps). Na základě Rb a řádu M lze spočítat výslednou vzorkovací rychlost.", tt_pulse: "Koeficient zakulacení (Rolloff) u RRC filtru. Tento filtr před vysíláním schválně maže obdélníkovým pulzům ostré rohy. Dělá to proto, aby vyzářený signál zbytečně nezabíral extrémní šířku frekvenčního pásma okolním zařízením.", tt_sf: "Spreading Factor u LoRy. Definuje délku písknutí (chirpu) potažmo celou rychlost a délku přenášeného symbolu. Vyšší SF zásadně prodlužuje let signálu, ale drasticky pohlcuje přenosovou rychlost dat.", tt_bw: "Frekvenční šířka pásma u LoRy (Chirp Spread Spectrum). Zvyšuje-li se BW, nabere hvizd širší rozestup, což zkrátí délku chirpu a urychlí přenos symobu. BW má tak vliv na kapacitu kanálu.", tt_chips: "Délka PRN kódu (tzv. čipy) na jeden informační bit. Jeden pomalý a čitelný bit zprávy je nasekán ('rozprostřen') na obrovské množství kratičkých náhodných čipů, což z něj pro třetí stranu udělá rušivý šum.", tt_slots: "Počet úzkých pevných časových 'oken' (slotů), do kterých se trefuje velmi krátký, leč energeticky silný pulz o ostaním čase v tichu (Pulse Position a Time Hopping rádio).", tt_hop: "Rychlost přeskakování u FHSS rádio modulací. Udává, kolik přeskoků nosné frekvence provede vysílač s přijímačem za jednu sekundu, čímž unikají zarušení na jednom z kanálů.", tt_samples: "Čistě matematický parametr, udávající kolik drobných bodů/vzorků vykresluje náš JavaScript simulátor pro znázornění jediné modulační vlnky. Více bodů = hladší průběh grafu, těžší na procesor prohlížeče.", tt_symbol_count: "Kolik symbolů napočítáme pro celkovou velikost prováděné simulační dávky. Pokud snížíte toto číslo, odlehčíte webovému prohlížeči, jelikož signálová trasa bude krátká a rychlá na výpočet.", chart_1_title: "1) Zdrojová data (Bity)", chart_1_tt: "Náhodně vygenerovaná binární informace (1 a 0), kterou se snažíme přenést pomocí rádiových vln. Krok za krokem projdeme procesem mapování z 'počítačové' digitální podoby do elektrického napětí pro anténu.", chart_2_title: "2) Mapování / Kód", chart_2_tt: "Ukazuje způsob převodu několika binárních bitů do jedné logické hodnoty ('symbolu'). Namísto jedniček a nul může vzniknout složitější kód, například fázový úhel nebo šumová sekvence určující stav vlny.", chart_3_title: "3) Základní pásmo", chart_3_tt: "Reprezentace signálu v tzv. základním (nízkofrekvenčním) pásmu před 'posazením' na finální vysílací anténu. Pomocí matematických funkcí (I/Q složky) se tu konstrují hladké průběhy změn fáze i amplitudy skrze tvarovací filtry.", chart_4_title: "4) Technická analýza / Konstelace", chart_4_tt: "Analytický pohled do vlastností 'vyrobeného' signálu. Zobrazuje buď okamžitou aktuální frekvenci přenášenou v grafu níže (užitečné u LoRa či FSK), modulovou obálku (součtovou velikost energie) nebo reálné I/Q body nakreslené vedle sebe do kruhové konstelace.", chart_5_title: "5) Výstup RF kanálu", chart_5_tt: "Toto vlna nakonec vyletí z vaší antény a poletí rychlostí světla prostorem! Finální namodulovaná 'našponovaná' nosná Carrier frekvence obsahující skryté informace v jejích deformacích. Zářná demonstrace FM/AM/PM principů.", chart_2_sym_mapping: "2) Mapování symbolů", chart_2_spread_code: "2) Rozprostřený kód", chart_2_hop_code: "2) Kód přeskakování", chart_3_baseband: "3) Základní pásmo (Baseband)", chart_3_spread_sig: "3) Rozprostřený signál", chart_4_tech_vector: "4) Technická analýza (Vektor)", chart_4_tech_freq: "4) Technická analýza (Frekvence)", modm_qam_desc: "<strong>M-QAM (Kvadraturní amplitudová modulace):</strong> Pokročilá modulační technika, která mění současně amplitudu i fázi nosné vlny. Používá se všude tam, kde potřebujeme přenést ohromné množství dat – od rychlých 5G sítí, přes moderní Wi-Fi (např. Wi-Fi 6 používá 1024-QAM) až po digitální televizi (DVB-T2). Konstelace v Grafu 2 ukazuje rozložení symbolů do dvourozměrné mřížky. Čím více bodů (vyšší řád M), tím více bitů přeneseme jedním symbolem, ale body jsou k sobě blíž a jsou proto náchylnější k chybovosti způsobené šumem v kanálu.", modm_psk_desc: "<strong>M-PSK (Fázové klíčování):</strong> Modulace, při které nese informaci výhradně změna fáze (posunutí v čase) nosné sinusovky, zatímco její amplituda zůstává neměnná. Z grafu na pozici 2 (konstelační diagram) je jasně vidět, že všechny stavy symbolů leží na kružnici. Je mimořádně oblíbená v satelitních komunikacích, GPS, nebo pro spolehlivou komunikaci mobilních telefonů při špatném signálu, jelikož díky stabilní amplitudě nepotřebuje tak kvalitní a lineární zesilovače jako QAM.", modm_ask_desc: "<strong>M-ASK (Amplitudové klíčování):</strong> Nejjednodušší forma digitální modulace. Informace je zakódována čistě jen do změny výšky (amplitudy) nosné vlny (fáze se u ní vůbe nemění). Pokud by M=2, jedná se de facto o obyčejnou Morseovku (zapnuto/vypnuto) zvanou OOK. Přestože je velmi náchylná k poškození od amplitudového (např. atmosférického) šumu, stále se díky své naprosté jednoduchosti používá u levných optických přenosů, starších bezdrátových zvonků a ovladačů od vrat.", modm_fsk_desc: "<strong>M-FSK (Frekvenční klíčování):</strong> Namísto měnění síly signálu se k přenosu různých stavů používá přeskok mezi odlišnými frekvencemi (tóninami). Graf 4 tak místo konstelace ukazuje prudké změny okamžité frekvence. Tento způsob je velmi odolný proti rušení a útlumu (typické pro telemetrii, starší modemy, systémy v pásmu 433 MHz nebo komunikaci pagerů). I pro člověka by zněla M-FSK akusticky jako plynulé přeskakování tónů od hlubokých k vysokým.", modm_css_desc: "<strong>CSS (LoRa Chirp Spread Spectrum):</strong> Patentovaná revoluční technika firmy Semtech pro bateriově napájený 'Internet věcí' (IoT). Namísto jedné frekvence signál neustále plynule přelaďuje (píská odzdola nahoru) a tvoří takzvaný 'Chirp'. Do těchto hvizdů se zakóduje zpráva časovým odsazením začátku hvizdu. Modulace dokáže signál 'uhrabat' hluboko pod hranici šumu (na displeji by bylo zdánlivě ticho) a signál tak doletí od obyčejného senzoru i desítky kilometrů daleko s extrémně malou baterií.", modm_dsss_desc: "<strong>DSSS (Přímé rozprostření spektra):</strong> Původně vojenská technologie. Jeden informační bit je rozsekán na dlouhou sekvenci krátkých 'čipů' pomocí pseudonáhodného šumového kódu. Tím se signál doslova rozprostře a rozmaže do obří šířky pásma, takže pro nepřítele vypadá jen jako nezajímavý šum z vesmíru. Na přijímači se stejným tajným kódem signál znovu složí a vynoří ho nad rušičky. Tuto metodu dodnes bezpečně využívají GPS satelity k určení polohy z velmi slabých signálů na Zemi nebo starší standardy Wi-Fi.", modm_fhss_desc: "<strong>FHSS (Frekvenční přeskokování):</strong> Další formát rozprostřeného spektra, koncepčně navržený herečkou Hedy Lamarrovou za 2. světové války pro bezpečné řízení torpéd. Vysílač s přijímačem rychlostí blesku synchronně střídají nosnou frekvenci podle předem dohodnutého šifrovacího klíče (kódu přeskoků). Pokud nepřítel nebo cizí přístroj ruší jednu frekvenci, poškodí se jen nepatrný zlomek sekundy, než FHSS vysílačka znovu uskočí jinam. Využívá to dnes klasické Bluetooth, které přeskakuje frekvence klidně i 1600x za vteřinu.", modm_thss_desc: "<strong>THSS (Časově-přeskokové spektrum):</strong> Spočívá ve vysílání silných, avšak mimořádně kratičkých impulsů (záblesků) energie v přesně vypočítaných časových intervalech ('slotech'). Systém je z většiny času plně potichu a čeká. Výhodou je, že ohromné množství takových zařízení může sdílet absolutně stejné vysílací frekvenční pásmo najednou. Pravděpodobnost kolize jejich ultrarychlých krátkých pulzů v čase se totiž limitně blíží k nule. THSS je úzkým příbuzným formátů typických pro UWB (Ultra-Wideband)." }, pe = { menu_params: "Parameters", menu_presentation: "Presentation & Study", lbl_modulation: "Modulation Scheme", lbl_random_data: "Random Data", btn_regen: "Regen", lbl_order: "Order [M]", lbl_carrier: "Carrier [fc] kHz", lbl_bitrate: "Bit Rate [Rb] kbps", lbl_pulse: "Pulse α", lbl_sf: "LoRa SF", lbl_bw: "Bandwidth [BW]", lbl_chips: "Chips [L]", lbl_slots: "TH Slots", lbl_hop: "Hop [Rh]", lbl_samples: "Samples/Sym", lbl_symbol_count: "Symbol Count", btn_guide: "APPLICATION GUIDE", btn_presentation: "PRESENTATION MODE", header_title: "Modulation Lab", header_status: "System Status: Pico W - SIGNAL LOCK v4.0", divider_legend: "LEGEND / HELP", divider_engine: "ENGINE SETTINGS", help_initial: "Select modulation to see details.", info_source: "Source: Rb = {rb} kbps | Bit t = {t} ms", info_baseband: "Baseband: SPS = {sps} | f_sampling = {fs} kHz", tt_random_data: "When checked, the application generates new random data words upon every redraw. Use Regen to manually force new messages irrespective of parameter changes.", tt_order: "Modulation order. States the total amount of distinct unique states per symbol in the constellation. Let M increase and you send more bits per symbol at a risk of higher BER error susceptibility.", tt_carrier: "Carrier Frequency. The fundamental oscillating frequency of a sine wave transmitting data through your medium. Altering phase, amplitude or frequency carries the embedded message.", tt_bitrate: "Bit Rate speed indicating how many 1s and 0s are spouted per second (in kilobits kbps). Based on order M and Rb, the resulting samplerate is computed.", tt_pulse: "Rolloff coefficient shaping factor of the RRC filter. Flattens out sharp rectangular pulse edges prior transmissing to lower the extreme sideband frequency pollution emitted to neighbours.", tt_sf: "Spreading Factor for LoRa CSS. Defines chirp duration. Higher SF drastically improves range across tens of kilometers and penetrates walls but slashes your data rate exponentially.", tt_bw: "Frequency channel Bandwidth for CSS protocols. Spreading a larger bandwidth accelerates the up/down chirps sending the symbols faster based on Shannon-Hartley theorem.", tt_chips: "PRN code fragment length per one bit. Spreads a singular slow readable bit into many short burst noisy fragments protecting it against narrowband jamming out in the real world.", tt_slots: "Total number of tiny fixed time slots framing the highly focused but short energy impulses typical for Pulse Position and Time Hopping radio signals.", tt_hop: "Hopping speed applied in FHSS radio modulation. Denotes how many jumps between distinct carrier RF channels occur each second evading singular channel inferences.", tt_samples: "Strictly an engine rendering parameter defining simulation plot granularity. Determines count of sample points per symbol period. Higher values deliver smoother sine waves, taking a toll on your browser.", tt_symbol_count: "How many simulated symbols sum up into the global simulation buffer duration. Descending this length dramatically relieves computation burdens out of device browser.", chart_1_title: "1) Source Data (Bits)", chart_1_tt: "Random binary information (1 and 0 logic states) intended for payload delivery across the radio chain. Our starting point towards analog representation.", chart_2_title: "2) Mapping / Code", chart_2_tt: "Illustrates the conversion method tying a group of baseband bits into to a distinct logic unit (Symbol). Mapped to varied phase rotations, amplitudes or sequenced code noise.", chart_3_title: "3) Baseband Domain", chart_3_tt: "Signal representation in the immediate low-band level prior being mixed to RF frequencies. Uses mathematical I/Q components to synthesize smooth shaped waveforms applying filters.", chart_4_title: "4) Technical Analysis / Constellation", chart_4_tt: "Analytics inspection uncovering the underlying signal parameters. Plots real instantaneous frequency modulations (LoRa, FSK) or projects I/Q spatial vectors in a 2D constellation diagram.", chart_5_title: "5) RF Channel Output", chart_5_tt: "The final amplified analog frequency bouncing off your physical antenna at the speed of light. Modulated Carrier ready to penetrate distances illustrating textbook AM/FM/PM outcomes.", chart_2_sym_mapping: "2) Symbol Mapping", chart_2_spread_code: "2) Spreading Code", chart_2_hop_code: "2) Hopping Code", chart_3_baseband: "3) Baseband Domain", chart_3_spread_sig: "3) Spread Signal", chart_4_tech_vector: "4) Technical Analysis (Vector)", chart_4_tech_freq: "4) Technical Analysis (Freq)", modm_qam_desc: "<strong>M-QAM (Quadrature Amplitude Modulation):</strong> State of the art technique alternating wave phase and amplitude simultaneously. Essential in high-throughput applications powering modern 5G cellulars, Gigabit Wi-Fi 6 (1024-QAM) down to Digital TV broadcasters. The Chart 2 constellation presents symbols dispersed across a 2D grid matrix. While higher orders transmit more bits iteratively, denser constellation groupings demand immense SNR fidelity raising error odds drastically.", modm_psk_desc: "<strong>M-PSK (Phase Shift Keying):</strong> An approach encoding binary structure exclusively into carrier phase displacements keeping amplitude consistently flat. You can observe symbols aligned perfectly in a circle within the Chart 2 diagram. Immensely popular due to low requirements on amplifier linearity making it the de-facto standard for deep space Satellites, raw GPS signals or baseline reliable communication under bad mobile networks.", modm_ask_desc: "<strong>M-ASK (Amplitude Shift Keying):</strong> Simplest fundamental digital modulation modulating sole carrier voltage magnitude while keeping phase untouched. M=2 directly translates to plain OOK (On/Off Morse). Highly susceptible to atmospheric amplitude noise deterioration yet heavily utilized within legacy cheap infrared optics, doorbells or old gates remotes praising absolute hardware simplicity.", modm_fsk_desc: "<strong>M-FSK (Frequency Shift Keying):</strong> Information jumps amongst diverse frequency pitches rather than varying amplitudes. Chart 4 analysis shows immediate frequency deviations instead of stationary constellations. Yields excellent immunity against amplitude noise attenuations extensively featured in telemetry pipelines, pager communications and classic 433 MHz ISM band telemetry. Audibly, FSK sounds like seamless musical pitch skipping.", modm_css_desc: "<strong>CSS (LoRa Chirp Spread Spectrum):</strong> Semtech disruptive proprietary technique revolutionizing battery-operated 'Internet of Things'. Foregoes standard static frequencies sending a continuous sweeping 'Chirp' up or down the band. Modulated messages are staggered via tiny timing phase offsets of those chirps. Astounding receiver capability can dig out signatures deep under the noise floor propagating data tens of kilometers on miniature sensors.", modm_dsss_desc: "<strong>DSSS (Direct Sequence Spread Spectrum):</strong> Roots tracing to secret military radar tech. One informational bit shatters into dozens of miniature short fragments spread by pseudo-random noise codes. The transmission spreads ultra-wide looking virtually identical to ambient background noise from space rendering enemies clueless. Only receivers applying inverse cipher reconstruct the message above jammers securely. Powers up GPS pinpoint localization and legacy 802.11b Wi-Fis.", modm_fhss_desc: "<strong>FHSS (Frequency Hopping):</strong> Spread spectrum variation conceptualized by Hedy Lamarr defeating WWII torpedo jammers. The communicating endpoints hop across alternating carrier channel slots at insane sync speed following a cryptographic pseudo-string. In case foreign signals jam one channel, the disruption affects mere microsecond fractions before FHSS leaps away. Commonly utilized by Bluetooth shifting 1600 times a second.", modm_thss_desc: "<strong>THSS (Time Hopping Spread Spectrum):</strong> Broadly consists of radiating immensely strong but exceptionally brief sub-nanosecond energy bursts within rigorously computed time windows (slots); maintaining utter radio silence otherwise. Time Hopping allows astonishing quantities of nearby devices sharing identical frequencies simultaneously with collision probability reaching near mathematical zero boundaries. Correlated to UWB (Ultra-Wideband) foundations." }, L = { cs: me, en: pe }; let N = localStorage.getItem("modulationLabLang") || "cs"; function B(e) { return L[N] && L[N][e] ? L[N][e] : e } function he(e) { L[e] && (N = e, localStorage.setItem("modulationLabLang", e), D()) } function fe() { return N } function D() { document.querySelectorAll("[data-i18n]").forEach(a => { const s = a.getAttribute("data-i18n"); a.innerHTML = B(s) }), document.querySelectorAll("[data-i18n-tooltip]").forEach(a => { const s = a.getAttribute("data-i18n-tooltip"); a.setAttribute("data-tooltip", B(s)) }), window.dispatchEvent(new Event("languageChanged")) } const Z = window.Plotly; function be(e, t) { const a = t ? e ? "#000000" : "#ffffff" : e ? "#1f2937" : "#ea7603", s = t ? e ? "rgba(0,0,0,0.2)" : "rgba(255,255,255,0.15)" : e ? "rgba(0,0,0,0.08)" : "rgba(234,118,3,0.08)", o = t ? e ? "rgba(0,0,0,0.5)" : "rgba(255,255,255,0.4)" : e ? "rgba(0,0,0,0.25)" : "rgba(234,118,3,0.2)"; return { paper_bgcolor: "rgba(0,0,0,0)", plot_bgcolor: e ? "rgba(255,255,255,0)" : "rgba(0,0,0,0.1)", font: { color: a, size: t ? 12 : 10, family: "JetBrains Mono, monospace", weight: e || t ? "bold" : "normal" }, margin: { t: 10, r: 15, l: 45, b: 30 }, xaxis: { gridcolor: s, zerolinecolor: o, tickfont: { size: t ? 10 : 9 }, linecolor: a, linewidth: t ? 2 : 1 }, yaxis: { gridcolor: s, zerolinecolor: o, tickfont: { size: t ? 10 : 9 }, linecolor: a, linewidth: t ? 2 : 1 } } } function ye(e, t) { return { trace1: t ? e ? "#0000cc" : "#00ffff" : e ? "#6b7280" : "#8ca4b5", trace2: t ? e ? "#cc00cc" : "#ff00ff" : e ? "#005a9e" : "#4ba3e3", trace3: t ? e ? "#008800" : "#00ff00" : e ? "#a3a3a3" : "#737373", trace4: t ? e ? "#cc5500" : "#ff9900" : "#ea7603" } } function x(e, t, a, s) { if (!Z) { console.error("Plotly library not loaded!"); return } Z.react(e, t, Object.assign({ autosize: !0 }, a), Object.assign({ responsive: !0 }, s)) } function ge(e, t) { e[0].textContent = B("info_source").replace("{rb}", (t.Rb / 1e3).toString()).replace("{t}", (1e3 / t.Rb).toFixed(3)), e[2].textContent = B("info_baseband").replace("{sps}", t.sps.toString()).replace("{fs}", (t.Rb * t.sps / 1e3).toFixed(1)) } let R = null, A = null, j = document.createElement("div"); j.className = "plot-placeholder chart-box"; j.textContent = "SIGNAL REDIRECTED TO FULLSCREEN..."; const J = new ResizeObserver(() => { R && O.Plots.resize(R) }); function ve(e, t, a) { function s(n) { const r = document.getElementById(n); r && (R = n, A = r.parentElement, j.style.width = r.offsetWidth + "px", j.style.height = r.offsetHeight + "px", A.replaceChild(j, r), t.appendChild(r), e.classList.remove("hidden"), document.body.classList.add("no-scroll"), document.documentElement.classList.add("no-scroll"), J.observe(t), setTimeout(() => O.Plots.resize(n), 50)) } function o() { if (!R) return; const n = document.getElementById(R); J.unobserve(t), A && n && (n.style.width = "", n.style.height = "", A.replaceChild(n, j)), e.classList.add("hidden"), document.body.classList.remove("no-scroll"), document.documentElement.classList.remove("no-scroll"); const r = R; R = null, A = null, setTimeout(() => { O.relayout(r, { width: null, height: null, autosize: !0 }), window.dispatchEvent(new Event("resize")), a() }, 50) } return { enterFocus: s, exitFocus: o } } function _e() { const e = document.createElement("div"); e.id = "global-tooltip", e.className = "global-tooltip hidden", document.body.appendChild(e), document.addEventListener("mouseover", t => { const a = t.target.closest("[data-tooltip]"); if (a) { const s = a.getAttribute("data-tooltip"); e.innerHTML = s, e.classList.remove("hidden"); const o = a.getBoundingClientRect(); let n = o.top, r = o.right + 10; r + 280 > window.innerWidth && (r = o.left - 290), n + e.offsetHeight > window.innerHeight && (n = window.innerHeight - e.offsetHeight - 10), e.style.top = n + "px", e.style.left = r + "px" } }), document.addEventListener("mouseout", t => { t.target.closest("[data-tooltip]") && e.classList.add("hidden") }) } function ke(e, t) { function a(s, o, n = !1) { !s || !o || (s.addEventListener("input", () => { o.value = n ? Math.pow(2, s.value) : s.value, t() }), o.addEventListener("input", () => { n ? s.value = Math.log2(Math.max(2, o.value)) : s.value = o.value, t() })) } a(e.mRange, e.mNum, !0), a(e.fcRange, e.fcNum), a(e.rbRange, e.rbNum), a(e.rollRange, e.rollNum), a(e.sfRange, e.sfNum), a(e.bwRange, e.bwNum), a(e.lRange, e.lNum), a(e.slotsRange, e.slotsNum), a(e.rhRange, e.rhNum), a(e.spsRange, e.spsNum), a(e.ncRange, e.ncNum) } function Me(e, t, a, s, o, n) { e.presBtn.addEventListener("click", () => { document.body.classList.toggle("presentation"), e.presBtn.classList.toggle("active"), setTimeout(() => { window.dispatchEvent(new Event("resize")), a() }, 50) }), e.themeBtn.addEventListener("click", () => { document.body.classList.toggle("light-theme"), a() }), e.langToggle && e.langToggle.addEventListener("click", () => { const r = fe() === "cs" ? "en" : "cs"; he(r) }), e.menuBtn && e.menuBtn.addEventListener("click", r => { const p = document.querySelector(".controls").classList.toggle("active"); e.menuBtn.textContent = p ? "✕" : "☰" }), document.addEventListener("click", r => { const i = document.querySelector(".controls"); i && i.classList.contains("active") && !i.contains(r.target) && !e.menuBtn.contains(r.target) && (i.classList.remove("active"), e.menuBtn.textContent = "☰") }), e.mod && e.mod.addEventListener("change", () => a(!0)), e.regenBtn && e.regenBtn.addEventListener("click", () => a(!0)), document.querySelectorAll(".focus-btn").forEach(r => { r.onclick = () => o(r.dataset.plot) }) } const z = new le, Se = () => { const e = M.mod; e.innerHTML = "", z.getAvailableModulations().forEach(a => { const s = document.createElement("option"); s.value = a.id, s.textContent = a.name, e.appendChild(s) }) }; let q = !1, H = !1; function C(e = !1) { e && (H = !0), !q && (q = !0, requestAnimationFrame(() => { ze(H || M.randomCheck.checked), H = !1, q = !1 })) } function Y(e) { const t = Object.values(K).map(i => i.containerClass).filter(Boolean), a = e.params.map(i => K[i].containerClass).filter(Boolean); t.forEach(i => { const p = document.querySelector("." + i); p && (p.style.display = a.includes(i) ? "flex" : "none") }), V && (V.innerHTML = B(e.help)); const s = document.getElementById("title-2-text"); s && (s.textContent = B(e.info2 || "chart_2_sym_mapping")); const o = document.getElementById("title-3-text"); o && (o.textContent = B(e.info3 || "chart_3_baseband")); const n = document.getElementById("title-4-text"); n && (n.textContent = B(e.info4 || "chart_4_tech_vector")); const r = document.querySelector('.focus-btn[data-plot="plot-const"]'); r && (r.style.display = e.showConstellation ? "inline-block" : "none") } function ze(e = !1) { const t = M.mod.value, a = z.getModulationDef(t); if (!a) return; const s = document.body.classList.contains("light-theme"), o = document.body.classList.contains("presentation"), n = be(s, o), r = ye(s, o), { trace1: i, trace2: p, trace3: f, trace4: g } = r; Y(a), z.M = parseInt(M.mNum.value) || 2, z.fc = parseFloat(M.fcNum.value) * 1e3, z.Rb = Math.max(.1, parseFloat(M.rbNum.value)) * 1e3, z.rolloff = parseFloat(M.rollNum.value), z.SF = parseInt(M.sfNum.value), z.BW = parseFloat(M.bwNum.value) * 1e3, z.L = parseInt(M.lNum.value), z.N_th = parseInt(M.slotsNum.value), z.Rh = parseFloat(M.rhNum.value), z.sps = parseInt(M.spsNum.value), z.Nc = parseInt(M.ncNum.value), ge(ie, z); const c = z.simulate(t, e); if (!c) return; const _ = 3e3, v = o ? 3 : 2; x("plot-1", [{ x: Array.from({ length: c.bits.length }, (d, m) => m), y: c.bits, mode: "lines", line: { shape: "hv", color: i, width: v }, fill: "tozeroy", fillcolor: s ? "rgba(0, 90, 158, 0.15)" : "rgba(139, 233, 253, 0.08)" }], { ...n, yaxis: { range: [-.2, 1.2], dtick: 1, gridcolor: n.xaxis.gridcolor, zerolinecolor: n.xaxis.zerolinecolor } }, { displayModeBar: !1 }); let l = []; c.plot2Type ? l = [{ x: c.extras.plot2_x, y: c.extras.plot2_y, mode: c.plot2Type, line: { width: v - .5, color: p }, marker: { color: p, size: o ? 8 : 6 } }] : l = [{ x: Array.from({ length: c.symbols.length }, (d, m) => m), y: c.symbols.map(d => d.val), mode: "markers", marker: { color: p, size: o ? 8 : 6 }, error_y: { type: "data", array: c.symbols.map(d => 0), arrayminus: c.symbols.map(d => d.val), color: p, width: v - 1 } }], x("plot-2", l, { ...n }, { displayModeBar: !1 }), x("plot-3", [{ x: c.t.slice(0, _), y: c.bbI.slice(0, _), name: "I", line: { color: f, width: v } }, { x: c.t.slice(0, _), y: c.bbQ.slice(0, _), name: "Q", line: { color: p, width: v } }], { ...n }, { displayModeBar: !1 }); let u = []; if (a.isVector || c.isVector) if (c.extras && c.extras.envelope) u = [{ x: c.t.slice(0, _), y: c.extras.envelope.slice(0, _), line: { color: g, width: v } }]; else { const d = c.bbI.slice(0, _).map((m, b) => Math.atan2(c.bbQ[b], m)); u = [{ x: c.t.slice(0, _), y: d, line: { color: g, width: v - .5 } }] } else u = [{ x: c.t.slice(0, _), y: c.fInst.slice(0, _).map(d => d / 1e3), line: { color: g, width: v } }]; if (x("plot-4", u, { ...n }, { displayModeBar: !1 }), a.showConstellation) { let d = { ...n, margin: { t: 10, r: 10, l: 35, b: 35 }, xaxis: { range: [-2, 2], dtick: 1, linewidth: 2, linecolor: n.xaxis.linecolor }, yaxis: { range: [-2, 2], scaleanchor: "x", dtick: 1, linewidth: 2, linecolor: n.yaxis.linecolor } }, m = c.symbols[0] && c.symbols[0].I !== void 0 ? [{ x: c.symbols.map(b => b.I), y: c.symbols.map(b => b.Q), mode: "markers", type: "scatter", marker: { color: f, size: o ? 6 : 4 } }] : [{ x: c.bbI.slice(0, 1e3), y: c.bbQ.slice(0, 1e3), mode: "lines", line: { color: f, width: v - .5 } }]; x("plot-const", m, d, { displayModeBar: !1 }) } x("plot-5", [{ x: c.t.slice(0, 5e3), y: c.pb.slice(0, 5e3), line: { color: i, width: v - .5 } }], { ...n }, { displayModeBar: !1 }) } Se(); D(); _e(); const { enterFocus: we, exitFocus: Ie } = ve(de, ue, C); ke(M, C); Me(M, z, C, D, we); localStorage.getItem("modulationLabGuided") || $.classList.remove("hidden"); ce.addEventListener("click", () => { $.classList.add("hidden"), localStorage.setItem("modulationLabGuided", "true") }); window.addEventListener("languageChanged", () => { const e = M.mod ? M.mod.value : "qam", t = z.getModulationDef(e); t && Y(t) }); U && U.addEventListener("click", Ie); C(!0);
